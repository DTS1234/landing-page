<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>3DM Viewer</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
      input[type="file"] {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 1;
      }
    </style>
  </head>
  <body>
    <input type="file" id="file-input" accept=".glb"/>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@<version>/examples/jsm/"
        }
      }
      </script>

    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.1/examples/jsm/controls/OrbitControls.js';
      import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.1/examples/jsm/loaders/GLTFLoader.js';

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf0f0f0);

      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(5, 5, 10);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(10, 10, 10);
      scene.add(directionalLight);

      // surface
      // 1. Create polygon surface (e.g. ground plane)
      const shape = new THREE.Shape();
      shape.moveTo(0, 0);
      shape.lineTo(100, 0);
      shape.lineTo(100, 100);
      shape.lineTo(0, 100);
      shape.lineTo(0, 0);

      const geometry = new THREE.ShapeGeometry(shape);
      geometry.computeBoundingBox();

      const center = new THREE.Vector3();
      geometry.boundingBox.getCenter(center);
      geometry.translate(-center.x, -center.y, -center.z);

      const textureLoader = new THREE.TextureLoader();
      const grassTexture = textureLoader.load('https://threejs.org/examples/textures/grasslight-big.jpg');
      grassTexture.wrapS = THREE.RepeatWrapping;
      grassTexture.wrapT = THREE.RepeatWrapping;
      grassTexture.repeat.set(10, 10);

      const material = new THREE.MeshStandardMaterial({ map: grassTexture, side: THREE.DoubleSide });
      const surface = new THREE.Mesh(geometry, material);
      surface.rotation.x = -Math.PI / 2; // Make it horizontal

      // 2. Set placement point on surface (e.g. center)
      const placeX = 5;
      const placeZ = 5;
      const placeY = 0; // Flat surface at y=0

      const loader = new GLTFLoader();

      let previousModel = null;

      document.getElementById('file-input').addEventListener('change', event => {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function (e) {
      console.log("loading file...");
      loader.parse(e.target.result, '', gltf => {
      if (previousModel) {
      scene.remove(previousModel);
      }

      // 1. Center the loaded model
      const box = new THREE.Box3().setFromObject(gltf.scene);
      const center = box.getCenter(new THREE.Vector3());
      gltf.scene.position.sub(center); // Move model so it's centered at (0,0,0)


      // 2. Create a group to hold both model and surface
      const group = new THREE.Group();
      group.add(gltf.scene);


      const surfaceClone = surface.clone();
      surfaceClone.position.y = -4.5; // make sure it's flat

      group.add(surfaceClone);

      // 3. Place the whole group at your desired location
      group.position.copy(center);
      group.position.y = 0
      scene.add(group);
      previousModel = group;

      // 4. Move the camera to look at the group
      const groupBox = new THREE.Box3().setFromObject(group);
      const groupSize = groupBox.getSize(new THREE.Vector3()).length();
      const groupCenter = groupBox.getCenter(new THREE.Vector3());

      camera.position.set(groupCenter.x, groupCenter.y + groupSize, groupCenter.z + groupSize);
      camera.lookAt(groupCenter);
      controls.target.copy(groupCenter);
      controls.update();

      console.log("done...");
      }, error => {
      console.error('GLB parsing error:', error);
      });
      };
      reader.readAsArrayBuffer(file);
      });


      console.log(scene)

      function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
      }

      animate();

      window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
